---
title: 第四章-指令系统
date: 2022-07-30
order: 4
toc: true
headerDepth: 2
---

## 指令寻址

- 确定下一条要执行的指令的存放地址
- 由程序计数器PC指明

### 顺序寻址

(PC)+"1"->PC, 此处的"1"理解为1个指令字长, 每次取指令结束后, 一定会PC+"1"

> 系统采用变长指令字结构, 指令字长=存储字长=16bit=2B, 主存按照字节编址
> <br> 读入一个字, 根据操作码判断这条指令的总字节数n, 修改PC的值, (PC)+n->PC
> <br> 根据指令的类型, CPU可能还要进行多次访存, 每次读入一个字

### 跳跃寻址

执行转移类指令导致PC的值改变, 类似于无条件转移指令JMP等

## 数据寻址

形式地址, 简称为A; 真实地址, 简称为EA

> 假设指令字长=机器字长=存储字长, 操作数为3

### 直接寻址

指令字中的形式地址A就是操作数的真实地址EA, 即EA=A

一次指令的执行:
1. 取指令 访存1次
2. 执行指令 访存1次
<br> 暂不考虑存结果, 共访存2次

优点: 简单, 指令执行阶段仅访问一次主存, 不需要专门计算操作数的地址

### 间接寻址

指令的地址字段给出的形式地址不是操作数真正的地址, 而是操作数有效地址所在的存储单元的地址, 也就是操作数地址的地址. 根据间接寻址的次数可以分为一次间接寻址和两次间接寻址

优点: 
- 可扩大寻址范围(有效寻址EA的位数大于形式地址A的位数)
- 便于编制程序(用间接寻址可以方便地完成子程序地返回)

### 寄存器寻址

在指令字中直接给出操作数所在地寄存器编号, 即EA=Ri, 其操作数在由Ri所指地寄存器内.

一次指令的执行: 
1. 取指令 访存1次
2. 执行指令 访存0次
<br> 暂不考虑存结果, 共访存1次

优点: 
- 指令在执行阶段不访问主存, 只访问寄存器
- 指令字短且执行速度快, 支持向量/矩阵运算

缺点: 寄存器价格昂贵, 计算机中寄存器的个数有限

### 寄存器简介寻址

寄存器Ri中给出的不是一个操作数, 而是操作数所在主存单元的地址, 即EA=(Ri)

一次指令的执行:
1. 取指令 访存1次
2. 执行指令 访存1次
<br> 暂不考虑存结果, 共访存2次

特点: 与一般间接寻址相比速度更快, 但指令的执行阶段需要访问主存(因为操作数在主存中)

### 隐含寻址

隐含寻址: 不是明显地给出操作数的地址, 而是在指令中隐含着操作数的地址

优点: 有利于缩短指令字长

缺点: 需要增加存储操作数或者隐含地址的硬件

### 立即寻址

形式地址A就是操作数本身, 又称为立即数, 一般采用补码形式. #表示立即寻址特征

一条指令的执行:
1. 取指令 访存1次
2. 执行指令 访存0次
<br> 暂不考虑存结果, 共访存1次

优点: 指令执行阶段不访问主存, 指令执行时间最短

缺点: A的位数限制了立即数的范围

### 偏移寻址

#### 基址寻址

将CPU中基址寄存器(BR)中的内容加上指令格式中的形式地址A, 而形成操作数的有效地址, 即EA=(BR)+A

有两种方法:
1. 采用专用寄存器BR作为基址寄存器
2. 采用通用寄存器作为基址寄存器, 在指令中需要指明, 要将哪个通用寄存器作为基址寄存器使用, 一般用R0表示

优点: 便于程序"浮动", 方便实现多道程序并发运行

拓展: 程序运行前, CPU将BR的值修改为该程序的起始地址(存在操作系统PCB中)

注: 
- 基址寄存器是面向操作系统的, 其内容是由操作系统或者管理程序确定. 在程序执行过程中, 基址寄存器的内容不变(作为基地址), 形式地址可变(作为偏移量)
- 当采用通用寄存器作为基址寄存器时, 可由用户决定哪个寄存器作为基址寄存器, 但其内容仍由操作系统决定

#### 变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和, 即EA=(IX)+A, 其中IX可为变址寄存器(专用), 也可用通用寄存器作为变址寄存器

注: 变址寄存器是面向用户的, 在程序执行的过程中, 变址寄存器的内容可由用户改变(IX作为偏移量), 形式地址A不变(作为基地址)

变址寻址作用: 在数组处理的过程中, 可设定A为数组的首地址, 不断改变变址寄存器IX的内容, 便可以很容易形成数组中任一数据的地址, 特别适合编制循环程序

#### 基址&变址复合寻址

- 基址寻址: EA=(BR)+A
- 变址寻址: EA=(IX)+A
- 先基址后变址寻址: EA=(IX)+(BX)+A

#### 相对寻址

把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址, 即EA=(PC)+A, 其中A是相对于PC所指地址的位移量, 可正可负, 补码表示

注: 王道书上的小错误 -- "A是相当于当前指令地址的位移量"这句话是错误的, 因为取出当前指令后, PC+"1"指向的是下一条指令

优点: 操作数的地址不是固定的, 它随着PC的值的变化而变化, 并且与指令地址之间总是相差一个固定的值, 因此便于程序浮动(一段代码在程序内部的浮动), 相对寻址广泛用于转移指令

### 堆栈寻址

操作数放在堆栈中, 隐含使用堆栈指针(SP)作为操作数地址

堆栈是存储器(或专用寄存器组)中一块特定的按"后进先出(LIFO)"原则管理的存储区, 该存储区中被读/写单元的地址是用一个特定的寄存器给出的, 该寄存器称为堆栈指针(SP)

## CISC&RISC

### CISC和RISC

80-20规律: 典型程序中80%的语句仅仅使用处理机中20%的指令

#### CISC

CISC: Complex Instruction Set Computer

设计思路: 一条指令完成一个复杂的基本功能

代表: X86架构, 主要用于笔记本, 台式机等

> 比如设计一套能实现整数, 矩阵加/减/乘运算的指令集
> <br> CISC的设计思路: 除了提供整数的加减乘指令除之外, 还提供矩阵的加法指令, 矩阵的减法指令, 矩阵的乘法指令.
> <br> 一条指令可以由一个专门的电路完成
> <br> 有的复杂指令用纯硬件实现很困难, 采用"存储程序"的设计思想, 由一个比较通用的电路配合存储部件完成一条指令

#### RISC

设计思路: 一条指令完成一个基本"动作"; 多条指令组合完成一个复杂的基本功能

代表: ARM架构, 主要用于手机, 平板等

> 比如设计一套能实现整数, 矩阵加/减/乘运算的指令集
> <br> RISC的思路: 只提供整数的加减乘指令
> <br> 一条指令一个电路, 电路设计相对简单, 功耗更低

### 区别

|                    | CISC                                 | RISC                                 |
| ------------------ | ------------------------------------ | ------------------------------------ |
| 指令系统           | 复杂, 庞大                           | 简单, 精简                           |
| 指令数目           | 一般大于200条                        | 一般小于100条                        |
| 指令字长           | 不固定                               | 定长                                 |
| 可访存指令         | 不加限制                             | 只有Load/Store指令                   |
| 各种指令执行时间   | 相差较大                             | 绝大多数在一个周期内完成             |
| 各种指令的使用频度 | 相差很大                             | 都比较常用                           |
| 通用寄存器数量     | 较少                                 | 多                                   |
| 目标代码           | 难以用优化编译生成搞笑的目标代码程序 | 采用优化的编译程序, 生成代码较为高效 |
| 控制方式           | 绝大多数为微程序控制                 | 绝大多数为组合逻辑控制               |
| 指令流水线         | 可以通过一定方式实现                 | 必须实现                             |

