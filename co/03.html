<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.49" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://vuepress-theme-hope-v2-demo.mrhope.site/csnote/co/03.html"><meta property="og:site_name" content="CS-Note"><meta property="og:title" content="第三章-存储系统"><meta property="og:type" content="article"><meta property="og:updated_time" content="2022-10-18T08:52:09.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:published_time" content="2022-07-30T00:00:00.000Z"><meta property="article:modified_time" content="2022-10-18T08:52:09.000Z"><title>第三章-存储系统 | CS-Note</title><meta name="description" content="CS-Note">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/csnote/assets/style.ae10c9ac.css">
    <link rel="modulepreload" href="/csnote/assets/app.931c373c.js"><link rel="modulepreload" href="/csnote/assets/03.html.ddce2241.js"><link rel="modulepreload" href="/csnote/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/csnote/assets/03.html.eb7d1931.js"><link rel="prefetch" href="/csnote/assets/index.html.a30f02bd.js"><link rel="prefetch" href="/csnote/assets/home.html.de83ec6a.js"><link rel="prefetch" href="/csnote/assets/slide.html.d5c34d3a.js"><link rel="prefetch" href="/csnote/assets/01.html.f58664a7.js"><link rel="prefetch" href="/csnote/assets/02.html.b60da16f.js"><link rel="prefetch" href="/csnote/assets/04.html.7b8036a1.js"><link rel="prefetch" href="/csnote/assets/05.html.753f2fcb.js"><link rel="prefetch" href="/csnote/assets/index.html.7f69debf.js"><link rel="prefetch" href="/csnote/assets/01.html.3c29eaee.js"><link rel="prefetch" href="/csnote/assets/02.html.4b2ce318.js"><link rel="prefetch" href="/csnote/assets/03.html.88d7a0df.js"><link rel="prefetch" href="/csnote/assets/04.html.935a0020.js"><link rel="prefetch" href="/csnote/assets/05.html.c5756ccb.js"><link rel="prefetch" href="/csnote/assets/06.html.6e52d21b.js"><link rel="prefetch" href="/csnote/assets/07.html.53907645.js"><link rel="prefetch" href="/csnote/assets/08.html.cc4782cc.js"><link rel="prefetch" href="/csnote/assets/index.html.00897127.js"><link rel="prefetch" href="/csnote/assets/index.html.c889cacc.js"><link rel="prefetch" href="/csnote/assets/01-概述.html.c487652d.js"><link rel="prefetch" href="/csnote/assets/02-物理层.html.2c0777e2.js"><link rel="prefetch" href="/csnote/assets/03-数据链路层.html.36553064.js"><link rel="prefetch" href="/csnote/assets/04-网络层.html.10a5de6c.js"><link rel="prefetch" href="/csnote/assets/05-传输层.html.64ebfd6a.js"><link rel="prefetch" href="/csnote/assets/06-应用层.html.3ee4f03d.js"><link rel="prefetch" href="/csnote/assets/07-面试常客.html.07f7f185.js"><link rel="prefetch" href="/csnote/assets/index.html.1cf839c4.js"><link rel="prefetch" href="/csnote/assets/ping原理.html.4c8baa17.js"><link rel="prefetch" href="/csnote/assets/01.html.ace333d4.js"><link rel="prefetch" href="/csnote/assets/02.html.65784ee8.js"><link rel="prefetch" href="/csnote/assets/03..html.45a5ac14.js"><link rel="prefetch" href="/csnote/assets/04.html.9ed0cc4c.js"><link rel="prefetch" href="/csnote/assets/05.html.b7368372.js"><link rel="prefetch" href="/csnote/assets/index.html.aed94aa3.js"><link rel="prefetch" href="/csnote/assets/404.html.12aa2354.js"><link rel="prefetch" href="/csnote/assets/index.html.27f3ea4d.js"><link rel="prefetch" href="/csnote/assets/index.html.521c7a3f.js"><link rel="prefetch" href="/csnote/assets/index.html.ab70fbbf.js"><link rel="prefetch" href="/csnote/assets/index.html.be5ad63e.js"><link rel="prefetch" href="/csnote/assets/index.html.4f694565.js"><link rel="prefetch" href="/csnote/assets/index.html.f635042b.js"><link rel="prefetch" href="/csnote/assets/index.html.52a228cd.js"><link rel="prefetch" href="/csnote/assets/index.html.144872d6.js"><link rel="prefetch" href="/csnote/assets/home.html.95b07c39.js"><link rel="prefetch" href="/csnote/assets/slide.html.db310a17.js"><link rel="prefetch" href="/csnote/assets/01.html.e6d0a4ab.js"><link rel="prefetch" href="/csnote/assets/02.html.c1595d14.js"><link rel="prefetch" href="/csnote/assets/04.html.a030e5b4.js"><link rel="prefetch" href="/csnote/assets/05.html.e72a4cde.js"><link rel="prefetch" href="/csnote/assets/index.html.e5569238.js"><link rel="prefetch" href="/csnote/assets/01.html.b2f9293a.js"><link rel="prefetch" href="/csnote/assets/02.html.1a5329f8.js"><link rel="prefetch" href="/csnote/assets/03.html.77b3cdfc.js"><link rel="prefetch" href="/csnote/assets/04.html.27da6634.js"><link rel="prefetch" href="/csnote/assets/05.html.e0a9a5de.js"><link rel="prefetch" href="/csnote/assets/06.html.f6758335.js"><link rel="prefetch" href="/csnote/assets/07.html.46945a90.js"><link rel="prefetch" href="/csnote/assets/08.html.fa37cca9.js"><link rel="prefetch" href="/csnote/assets/index.html.23fe8d82.js"><link rel="prefetch" href="/csnote/assets/index.html.242ba130.js"><link rel="prefetch" href="/csnote/assets/01-概述.html.65efed09.js"><link rel="prefetch" href="/csnote/assets/02-物理层.html.fd80a8e0.js"><link rel="prefetch" href="/csnote/assets/03-数据链路层.html.4d963065.js"><link rel="prefetch" href="/csnote/assets/04-网络层.html.fb6b67ea.js"><link rel="prefetch" href="/csnote/assets/05-传输层.html.05353c51.js"><link rel="prefetch" href="/csnote/assets/06-应用层.html.2b400f32.js"><link rel="prefetch" href="/csnote/assets/07-面试常客.html.b4f1102e.js"><link rel="prefetch" href="/csnote/assets/index.html.5543816a.js"><link rel="prefetch" href="/csnote/assets/ping原理.html.a6ad956e.js"><link rel="prefetch" href="/csnote/assets/01.html.584c36fc.js"><link rel="prefetch" href="/csnote/assets/02.html.96849abf.js"><link rel="prefetch" href="/csnote/assets/03..html.bf71854f.js"><link rel="prefetch" href="/csnote/assets/04.html.c8792279.js"><link rel="prefetch" href="/csnote/assets/05.html.bd51c984.js"><link rel="prefetch" href="/csnote/assets/index.html.0f572c57.js"><link rel="prefetch" href="/csnote/assets/404.html.39cab555.js"><link rel="prefetch" href="/csnote/assets/index.html.f44f6934.js"><link rel="prefetch" href="/csnote/assets/index.html.bcf59c23.js"><link rel="prefetch" href="/csnote/assets/index.html.46a1ee11.js"><link rel="prefetch" href="/csnote/assets/index.html.13f89940.js"><link rel="prefetch" href="/csnote/assets/index.html.3e3156d5.js"><link rel="prefetch" href="/csnote/assets/index.html.ee5693ce.js"><link rel="prefetch" href="/csnote/assets/index.html.d27e6ef1.js"><link rel="prefetch" href="/csnote/assets/404.22f5b45a.js"><link rel="prefetch" href="/csnote/assets/Layout.fb88192c.js"><link rel="prefetch" href="/csnote/assets/Slide.387456a3.js"><link rel="prefetch" href="/csnote/assets/Blog.189a7889.js"><link rel="prefetch" href="/csnote/assets/giscus.1696b11c.js"><link rel="prefetch" href="/csnote/assets/auto.esm.2565cd3a.js"><link rel="prefetch" href="/csnote/assets/index.d8a59108.js"><link rel="prefetch" href="/csnote/assets/index.1842ee54.js"><link rel="prefetch" href="/csnote/assets/mermaid.esm.min.ee1e0284.js"><link rel="prefetch" href="/csnote/assets/highlight.esm.d982e650.js"><link rel="prefetch" href="/csnote/assets/markdown.esm.832a189d.js"><link rel="prefetch" href="/csnote/assets/math.esm.a3f84b6f.js"><link rel="prefetch" href="/csnote/assets/notes.esm.3c361cb7.js"><link rel="prefetch" href="/csnote/assets/reveal.esm.b96f05d8.js"><link rel="prefetch" href="/csnote/assets/search.esm.80da4a02.js"><link rel="prefetch" href="/csnote/assets/zoom.esm.8514a202.js"><link rel="prefetch" href="/csnote/assets/photoswipe.esm.218074cd.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc"><!--[--><!--[--><header class="navbar"><div class="navbar-left"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><a href="/csnote/" class="brand"><img class="logo" src="/csnote/logo.svg" alt="CS-Note"><!----><span class="site-name hide-in-pad">CS-Note</span></a><!----></div><div class="navbar-center"><!----><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/csnote/" class="nav-link" aria-label="CS-Note-WanXing"><span class="icon iconfont icon-home"></span>CS-Note-WanXing<!----></a></div><div class="nav-item hide-in-mobile"><a href="/csnote/net/" class="nav-link" aria-label="计算机网络"><span class="icon iconfont icon-edit"></span>计算机网络<!----></a></div><div class="nav-item hide-in-mobile"><a href="/csnote/ds/" class="nav-link" aria-label="数据结构"><span class="icon iconfont icon-edit"></span>数据结构<!----></a></div><div class="nav-item hide-in-mobile"><a href="/csnote/co/" class="nav-link active" aria-label="组成原理"><span class="icon iconfont icon-edit"></span>组成原理<!----></a></div><div class="nav-item hide-in-mobile"><a href="/csnote/os/" class="nav-link" aria-label="操作系统"><span class="icon iconfont icon-edit"></span>操作系统<!----></a></div><div class="nav-item hide-in-mobile"><a href="/csnote/life/" class="nav-link" aria-label="生活记录"><span class="icon iconfont icon-edit"></span>生活记录<!----></a></div></nav><!----></div><div class="navbar-right"><!----><!----><div class="nav-item"><a class="repo-link" href="https://github.com/WannXing/csnote" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-creative"></span><a href="/csnote/net/" class="title">计算机网络</a><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-creative"></span><a href="/csnote/ds/" class="title">数据结构</a><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="icon iconfont icon-creative"></span><a href="/csnote/co/" class="title">计算机组成原理</a><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/csnote/co/" class="nav-link sidebar-link sidebar-page" aria-label="计算机组成原理"><!---->计算机组成原理<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/csnote/co/01.html" class="nav-link sidebar-link sidebar-page" aria-label="第一章-计算机系统概述"><!---->第一章-计算机系统概述<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/csnote/co/02.html" class="nav-link sidebar-link sidebar-page" aria-label="第二章-数据的表示和运算"><!---->第二章-数据的表示和运算<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/csnote/co/03.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="第三章-存储系统"><!---->第三章-存储系统<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-1-存储系统基本概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.1 存储系统基本概念"><!---->3.1 存储系统基本概念<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-存储器的层次化结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.存储器的层次化结构"><!---->1.存储器的层次化结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-存储器的分类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.存储器的分类"><!---->2.存储器的分类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-存储器的性能指标" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.存储器的性能指标"><!---->3.存储器的性能指标<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-2-主存储器的基本组成" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.2 主存储器的基本组成"><!---->3.2 主存储器的基本组成<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-基本的半导体元件及原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.基本的半导体元件及原理"><!---->1.基本的半导体元件及原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-寻址" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.寻址"><!---->2.寻址<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-3-sram-dram" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.3 SRAM&amp;DRAM"><!---->3.3 SRAM&amp;DRAM<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-栅极电容-v-s-双稳态触发器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.栅极电容 V.S. 双稳态触发器"><!---->1.栅极电容 V.S. 双稳态触发器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-dram的刷新" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.DRAM的刷新"><!---->2.DRAM的刷新<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#dram的地址线复用技术" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="DRAM的地址线复用技术"><!---->DRAM的地址线复用技术<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-4-read-only-memory-rom" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.4 read only memory ROM"><!---->3.4 read only memory ROM<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-了解各种rom" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.了解各种ROM"><!---->1.了解各种ROM<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-计算机内的重要rom" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.计算机内的重要ROM"><!---->2.计算机内的重要ROM<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-5-主存储器与cpu的连接" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.5 主存储器与CPU的连接"><!---->3.5 主存储器与CPU的连接<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-增加主存的字长-位扩展" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.增加主存的字长-位扩展"><!---->1.增加主存的字长-位扩展<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-增加主存的存储字数-字扩展" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.增加主存的存储字数-字扩展"><!---->2.增加主存的存储字数-字扩展<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-增加主存的存储字数-字位扩展" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.增加主存的存储字数-字位扩展"><!---->3.增加主存的存储字数-字位扩展<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-6-双口ram-多模块存储器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.6 双口RAM&amp;多模块存储器"><!---->3.6 双口RAM&amp;多模块存储器<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-存取周期" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.存取周期"><!---->1.存取周期<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-双端口ram" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.双端口RAM"><!---->2.双端口RAM<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-多体并行存储器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.多体并行存储器"><!---->3.多体并行存储器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_4-应该取第几个-体" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.应该取第几个&quot;体&quot;?"><!---->4.应该取第几个&quot;体&quot;?<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_5-多模块存储器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.多模块存储器"><!---->5.多模块存储器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_6-内存条" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.内存条"><!---->6.内存条<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-7-外部存储器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.7 外部存储器"><!---->3.7 外部存储器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-8-cache的基本概念和原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.8 Cache的基本概念和原理"><!---->3.8 Cache的基本概念和原理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-存储系统存在的问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.存储系统存在的问题"><!---->1.存储系统存在的问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-cache的工作原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.Cache的工作原理"><!---->2.Cache的工作原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-局部性原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.局部性原理"><!---->3.局部性原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_4-性能分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.性能分析"><!---->4.性能分析<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_5-有待解决的问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.有待解决的问题"><!---->5.有待解决的问题<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-9-cache和主存的映射方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.9 Cache和主存的映射方式"><!---->3.9 Cache和主存的映射方式<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-全相联映射-随意放" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.全相联映射(随意放)"><!---->1.全相联映射(随意放)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-直接映射-只能放固定位置" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.直接映射(只能放固定位置)"><!---->2.直接映射(只能放固定位置)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-组相联映射-可放到特定分组" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.组相联映射(可放到特定分组)"><!---->3.组相联映射(可放到特定分组)<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-10-cache替换算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.10 Cache替换算法"><!---->3.10 Cache替换算法<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-随机算法-rand" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.随机算法(RAND)"><!---->1.随机算法(RAND)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-先进先出算法-fifo" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.先进先出算法(FIFO)"><!---->2.先进先出算法(FIFO)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-近期最少使用算法-lru" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.近期最少使用算法(LRU)"><!---->3.近期最少使用算法(LRU)<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_4-最不经常使用算法-lfu" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.最不经常使用算法(LFU)"><!---->4.最不经常使用算法(LFU)<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-11-cache写策略" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.11 Cache写策略"><!---->3.11 Cache写策略<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-写命中" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.写命中"><!---->1.写命中<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-写不命中" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.写不命中"><!---->2.写不命中<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-多级cache" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.多级Cache"><!---->3.多级Cache<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-12-虚拟存储器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.12 虚拟存储器"><!---->3.12 虚拟存储器<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_1-页式虚拟存储器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.页式虚拟存储器"><!---->1.页式虚拟存储器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_2-快表tlb" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.快表TLB"><!---->2.快表TLB<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_3-tlb和cache的多级存储系统" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.TLB和Cache的多级存储系统"><!---->3.TLB和Cache的多级存储系统<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/csnote/co/03.html#_4-段式、段页式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.段式、段页式"><!---->4.段式、段页式<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/csnote/co/04.html" class="nav-link sidebar-link sidebar-page" aria-label="第四章-指令系统"><!---->第四章-指令系统<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/csnote/co/05.html" class="nav-link sidebar-link sidebar-page" aria-label="第五章-中央处理器"><!---->第五章-中央处理器<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="icon iconfont icon-creative"></span><a href="/csnote/os/" class="title">操作系统</a><span class="arrow right"></span></button><!----></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->第三章-存储系统</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" localizeddate="2022年7月30日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="author-item" href="https://WannXing.github.io" target="_blank" rel="noopener noreferrer">WanXing</a></span><span property="author" content="WanXing"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span>2022年7月30日</span><meta property="datePublished" content="2022-07-30T00:00:00.000Z"></span><!----><!----><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" localizeddate="2022年7月30日" isoriginal="false" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 27 分钟</span><meta property="timeRequired" content="PT27M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-1-存储系统基本概念" class="router-link-active router-link-exact-active toc-link level2">3.1 存储系统基本概念</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-存储器的层次化结构" class="router-link-active router-link-exact-active toc-link level3">1.存储器的层次化结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-存储器的分类" class="router-link-active router-link-exact-active toc-link level3">2.存储器的分类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-存储器的性能指标" class="router-link-active router-link-exact-active toc-link level3">3.存储器的性能指标</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-2-主存储器的基本组成" class="router-link-active router-link-exact-active toc-link level2">3.2 主存储器的基本组成</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-基本的半导体元件及原理" class="router-link-active router-link-exact-active toc-link level3">1.基本的半导体元件及原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-寻址" class="router-link-active router-link-exact-active toc-link level3">2.寻址</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-3-sram-dram" class="router-link-active router-link-exact-active toc-link level2">3.3 SRAM&amp;DRAM</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-栅极电容-v-s-双稳态触发器" class="router-link-active router-link-exact-active toc-link level3">1.栅极电容 V.S. 双稳态触发器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-dram的刷新" class="router-link-active router-link-exact-active toc-link level3">2.DRAM的刷新</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#dram的地址线复用技术" class="router-link-active router-link-exact-active toc-link level3">DRAM的地址线复用技术</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-4-read-only-memory-rom" class="router-link-active router-link-exact-active toc-link level2">3.4 read only memory ROM</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-了解各种rom" class="router-link-active router-link-exact-active toc-link level3">1.了解各种ROM</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-计算机内的重要rom" class="router-link-active router-link-exact-active toc-link level3">2.计算机内的重要ROM</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-5-主存储器与cpu的连接" class="router-link-active router-link-exact-active toc-link level2">3.5 主存储器与CPU的连接</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-增加主存的字长-位扩展" class="router-link-active router-link-exact-active toc-link level3">1.增加主存的字长-位扩展</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-增加主存的存储字数-字扩展" class="router-link-active router-link-exact-active toc-link level3">2.增加主存的存储字数-字扩展</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-增加主存的存储字数-字位扩展" class="router-link-active router-link-exact-active toc-link level3">3.增加主存的存储字数-字位扩展</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-6-双口ram-多模块存储器" class="router-link-active router-link-exact-active toc-link level2">3.6 双口RAM&amp;多模块存储器</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-存取周期" class="router-link-active router-link-exact-active toc-link level3">1.存取周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-双端口ram" class="router-link-active router-link-exact-active toc-link level3">2.双端口RAM</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-多体并行存储器" class="router-link-active router-link-exact-active toc-link level3">3.多体并行存储器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_4-应该取第几个-体" class="router-link-active router-link-exact-active toc-link level3">4.应该取第几个&quot;体&quot;?</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_5-多模块存储器" class="router-link-active router-link-exact-active toc-link level3">5.多模块存储器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_6-内存条" class="router-link-active router-link-exact-active toc-link level3">6.内存条</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-7-外部存储器" class="router-link-active router-link-exact-active toc-link level2">3.7 外部存储器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-8-cache的基本概念和原理" class="router-link-active router-link-exact-active toc-link level2">3.8 Cache的基本概念和原理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-存储系统存在的问题" class="router-link-active router-link-exact-active toc-link level3">1.存储系统存在的问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-cache的工作原理" class="router-link-active router-link-exact-active toc-link level3">2.Cache的工作原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-局部性原理" class="router-link-active router-link-exact-active toc-link level3">3.局部性原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_4-性能分析" class="router-link-active router-link-exact-active toc-link level3">4.性能分析</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_5-有待解决的问题" class="router-link-active router-link-exact-active toc-link level3">5.有待解决的问题</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-9-cache和主存的映射方式" class="router-link-active router-link-exact-active toc-link level2">3.9 Cache和主存的映射方式</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-全相联映射-随意放" class="router-link-active router-link-exact-active toc-link level3">1.全相联映射(随意放)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-直接映射-只能放固定位置" class="router-link-active router-link-exact-active toc-link level3">2.直接映射(只能放固定位置)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-组相联映射-可放到特定分组" class="router-link-active router-link-exact-active toc-link level3">3.组相联映射(可放到特定分组)</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-10-cache替换算法" class="router-link-active router-link-exact-active toc-link level2">3.10 Cache替换算法</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-随机算法-rand" class="router-link-active router-link-exact-active toc-link level3">1.随机算法(RAND)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-先进先出算法-fifo" class="router-link-active router-link-exact-active toc-link level3">2.先进先出算法(FIFO)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-近期最少使用算法-lru" class="router-link-active router-link-exact-active toc-link level3">3.近期最少使用算法(LRU)</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_4-最不经常使用算法-lfu" class="router-link-active router-link-exact-active toc-link level3">4.最不经常使用算法(LFU)</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-11-cache写策略" class="router-link-active router-link-exact-active toc-link level2">3.11 Cache写策略</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-写命中" class="router-link-active router-link-exact-active toc-link level3">1.写命中</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-写不命中" class="router-link-active router-link-exact-active toc-link level3">2.写不命中</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-多级cache" class="router-link-active router-link-exact-active toc-link level3">3.多级Cache</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-12-虚拟存储器" class="router-link-active router-link-exact-active toc-link level2">3.12 虚拟存储器</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_1-页式虚拟存储器" class="router-link-active router-link-exact-active toc-link level3">1.页式虚拟存储器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_2-快表tlb" class="router-link-active router-link-exact-active toc-link level3">2.快表TLB</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_3-tlb和cache的多级存储系统" class="router-link-active router-link-exact-active toc-link level3">3.TLB和Cache的多级存储系统</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/csnote/co/03.html#_4-段式、段页式" class="router-link-active router-link-exact-active toc-link level3">4.段式、段页式</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h2 id="_3-1-存储系统基本概念" tabindex="-1"><a class="header-anchor" href="#_3-1-存储系统基本概念" aria-hidden="true">#</a> 3.1 <a href="https://blog.csdn.net/qq_43896405/article/details/119785783" target="_blank" rel="noopener noreferrer">存储系统基本概念<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h2><h3 id="_1-存储器的层次化结构" tabindex="-1"><a class="header-anchor" href="#_1-存储器的层次化结构" aria-hidden="true">#</a> 1.存储器的层次化结构</h3><p><img src="https://img1.imgtp.com/2022/07/29/E0axxyRX.svg" alt="" loading="lazy"></p><ul><li>主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员透明</li><li>主存和辅存之间的数据调动由硬件和操作系统共同完成，对应用程序员透明</li><li>辅存中的数据要调入主存后才被CPU访问</li></ul><p><img src="https://img1.imgtp.com/2022/07/29/64sfGZu6.svg" alt="" loading="lazy"></p><p>有的教材把安装在电脑内部的磁盘称为&quot;辅存&quot;, 把U盘, 光盘等称为&quot;外存&quot;. 也有的教材把磁盘, U盘, 光盘等统称为&quot;辅存&quot;或者&quot;外存&quot;</p><ul><li>主存-辅存: 实现虚拟操作系统, 解决了主存容量不够的问题</li><li>Cache-主存: 解决了主存与CPU速度不匹配的问题</li></ul><h3 id="_2-存储器的分类" tabindex="-1"><a class="header-anchor" href="#_2-存储器的分类" aria-hidden="true">#</a> 2.存储器的分类</h3><h4 id="按照层次" tabindex="-1"><a class="header-anchor" href="#按照层次" aria-hidden="true">#</a> 按照层次</h4><ul><li>高速缓存(Cache)</li><li>主存储器(主存, 内存)</li><li>辅助存储器(辅存, 外存)</li></ul><h4 id="存储介质" tabindex="-1"><a class="header-anchor" href="#存储介质" aria-hidden="true">#</a> 存储介质</h4><ul><li>半导体存储器(主存, Cache)</li><li>磁表面存储器(磁盘, 磁带)</li><li>光存储器(光盘, DVD)</li></ul><h4 id="存取方式" tabindex="-1"><a class="header-anchor" href="#存取方式" aria-hidden="true">#</a> 存取方式</h4><ul><li>随机存取存储器(Random Access Memory, RAM): 读写任何一个存储单元所需的时间都相同, 与存储单元所在的物理位置无关</li><li>顺序存取存储器(Sequential Access Memory, SAM): 读写一个存储单元所需的时间取决于存储单元所在的物理位置</li><li>直接存取存储器(Direct Access Memory, DAM): 既有随机存取特性, 也有顺序存储的特性. 先直接选取信息所在的区域, 然后按照顺序方式存取</li><li>相联存储器(Associative Memory), 即可以按内容访问的存储器(Content Addressed Memory, CAM), 可以按照内容检索到存储位置进行读写, &quot;快表&quot;就是一种相联存储器</li></ul><blockquote><p>串行访问存储器: 读写某个存储单元所需的时间和存储单元的物理位置有关, 上述SAM和DAM就是串行访问存储器</p></blockquote><blockquote><p>RAM, SAM和DAM是按照地址来访问, CAM是按照内容来访问</p></blockquote><h4 id="信息的可更改性" tabindex="-1"><a class="header-anchor" href="#信息的可更改性" aria-hidden="true">#</a> 信息的可更改性</h4><ul><li>读写存储器(Read/Write Memory) -- 既可读, 也可写(如: 磁盘, 内存, Cache)</li><li>只读存储器(Read Only Memory) -- 只能读, 不能写(如: 实体音乐专辑通常采用的CD-ROM, 实体电影中采用的蓝光光碟, BIOS通常写在ROM中)</li></ul><h4 id="信息的可保存性" tabindex="-1"><a class="header-anchor" href="#信息的可保存性" aria-hidden="true">#</a> 信息的可保存性</h4><ul><li><p>断电后, 存储信息消失的存储器 -- 易失性存储器(主存, Cache)</p></li><li><p>断电后, 存储信息依然保持的存储器 -- 非易失性存储器(磁盘, 光盘)</p></li><li><p>信息读出后, 原存储信息被破坏 -- 破坏性读出(如DRAM芯片, 读出数据后要进行重写)</p></li><li><p>信息读出后, 原存储信息不会被破坏 -- 非破坏性读出(如SRAM芯片, 磁盘, 光盘)</p></li></ul><h3 id="_3-存储器的性能指标" tabindex="-1"><a class="header-anchor" href="#_3-存储器的性能指标" aria-hidden="true">#</a> 3.存储器的性能指标</h3><ul><li>存储容量: 存储字数*字长</li><li>单位成本: 每位价格=总成本/总容量</li><li>存储速度: 数据传输率=数据的宽度/存储周期</li></ul><ol><li>存储时间(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">T_a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>): 存取时间指的是从启动一次存储器操作到完成该操作所经历的时间, 分为读出时间和写入时间</li><li>存取周期(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>): 存取周期又称为读写周期或者访问周期, 它是指存储器进行一次完整的读写操作所需要的全部时间, 即连续两次独立地访问存储器操作(读或写操作)之间所需要的最小时间间隔</li><li>主存带宽(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">B_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0502em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>): 主存带宽又称为数据传输率, 表示每秒从主存进出信息的最大数量, 单位为字/秒, 字节/秒或者位/秒</li></ol><h2 id="_3-2-主存储器的基本组成" tabindex="-1"><a class="header-anchor" href="#_3-2-主存储器的基本组成" aria-hidden="true">#</a> 3.2 主存储器的基本组成</h2><h3 id="_1-基本的半导体元件及原理" tabindex="-1"><a class="header-anchor" href="#_1-基本的半导体元件及原理" aria-hidden="true">#</a> 1.基本的半导体元件及原理</h3><p><img src="https://img1.imgtp.com/2022/07/29/OjWzqbfg.svg" alt="" loading="lazy"></p><p>一个内存颗粒上的金属引脚:</p><ol><li>地址线</li><li>数据线</li><li>读写控制线(1个或2个)</li><li>片选线(1个)</li><li>供电引脚</li><li>接地引脚</li></ol><blockquote><p>常见的描述: <br> 8K*8位, 即2^13*8bit <br> 8K*1位, 即2^13*1bit <br> 64K*16位, 即2^16*16bit</p></blockquote><h3 id="_2-寻址" tabindex="-1"><a class="header-anchor" href="#_2-寻址" aria-hidden="true">#</a> 2.寻址</h3><p>总容量为1KB(字长4B):</p><ul><li>按照字节寻址: 1K个单元, 每个单元1B</li><li>按字寻址: 256个单元, 每个单元4B</li><li>按半字寻址: 512个单元, 每个单元2B</li><li>按双字寻址: 128个单元, 每个单元8B</li></ul><h2 id="_3-3-sram-dram" tabindex="-1"><a class="header-anchor" href="#_3-3-sram-dram" aria-hidden="true">#</a> 3.3 SRAM&amp;DRAM</h2><h3 id="_1-栅极电容-v-s-双稳态触发器" tabindex="-1"><a class="header-anchor" href="#_1-栅极电容-v-s-双稳态触发器" aria-hidden="true">#</a> 1.栅极电容 V.S. 双稳态触发器</h3><table><thead><tr><th>类型特点</th><th>SRAM(静态RAM)</th><th>DRAM(动态RAM)</th></tr></thead><tbody><tr><td>存储信息</td><td>触发器</td><td>电容</td></tr><tr><td>破坏性读出</td><td>非</td><td>是</td></tr><tr><td>读出后需要重写?</td><td>不用</td><td>需要</td></tr><tr><td>运行速度</td><td>快</td><td>慢</td></tr><tr><td>集成度</td><td>低</td><td>高</td></tr><tr><td>发热量</td><td>大</td><td>小</td></tr><tr><td>存储成本</td><td>高</td><td>低</td></tr><tr><td>易失/非易失存储器?</td><td>易失</td><td>易失</td></tr><tr><td>需要刷新?</td><td>不需要</td><td>需要(分散, 集中, 异步)</td></tr><tr><td>送行列地址</td><td>同时送</td><td>分两次送(地址线复用技术)</td></tr><tr><td>用途</td><td>常用作Cache</td><td>常用作主存</td></tr></tbody></table><h4 id="栅极电容-dram存储元" tabindex="-1"><a class="header-anchor" href="#栅极电容-dram存储元" aria-hidden="true">#</a> 栅极电容(DRAM存储元)</h4><p><img src="https://img1.imgtp.com/2022/07/29/JMULozM1.png" alt="" loading="lazy"></p><ul><li>读出1: MOS管接通, 电容放电, 数据线上产生电流</li><li>读出0: MOS管接通后, 数据线上无电流</li></ul><p>电容放电信息被破坏, 是破坏性读出, 读出后应有重写操作, 也成为&quot;再生&quot;, 读写速度更慢</p><p>每个存储单元制造成本更低, 集成度更高, 功耗低</p><h4 id="双稳态触发器-sram存储元" tabindex="-1"><a class="header-anchor" href="#双稳态触发器-sram存储元" aria-hidden="true">#</a> 双稳态触发器(SRAM存储元)</h4><p><img src="https://img1.imgtp.com/2022/07/29/As4U9VxO.png" alt="" loading="lazy"></p><p>双稳态: <br> 1: A高B低 <br> 0: A低B高</p><p>读出数据, 触发器状态保持稳定, 是非破坏性读出, 无需重写, 读写速度更快</p><p>每个存储单元制造成本更高, 集成度低, 功耗大</p><h3 id="_2-dram的刷新" tabindex="-1"><a class="header-anchor" href="#_2-dram的刷新" aria-hidden="true">#</a> 2.DRAM的刷新</h3><ol><li>多久刷新一次? 刷新周期: 一般为2ms</li><li>刷新方式 <ul><li>集中刷新：在一个刷新周期内，利用一段固定的时间，依次对所有行逐一再生（死时间）</li><li>分散刷新：把对每行的刷新分散到各个工作周期中，工作周期前半部分读写，后半部分刷新 <ul><li>增加了系统的存取周期，降低了整机的速度</li></ul></li><li>异步刷新：将刷新周期除以行数，得到两次刷新操作之间的时间间隔，每隔时间间隔进行一次刷新操作</li></ul></li><li>注 <ul><li>刷新对CPU是透明的，刷新不依赖于外部的访问</li><li>刷新单位是行，由芯片内部自行生成行地址</li><li>刷新不需要选片，所有芯片同时刷新</li></ul></li></ol><h4 id="为什么要用行列地址" tabindex="-1"><a class="header-anchor" href="#为什么要用行列地址" aria-hidden="true">#</a> 为什么要用行列地址?</h4><blockquote><p>地址为00000000, 前半部分(0000)作为行地址送给行地址译码器, 后半部分(0000)作为列地址送给列地址译码器. 如果采用非矩阵模型, 则需要2^8=256根选通线, 如果采用矩阵模型, 则需要2<sup>4+2</sup>4根选通线(排列成16*16的矩阵)</p></blockquote><h4 id="在什么时刻刷新" tabindex="-1"><a class="header-anchor" href="#在什么时刻刷新" aria-hidden="true">#</a> 在什么时刻刷新?</h4><blockquote><p>假设DRAM内部结构排列成128*128的形式, 读/写周期0.5us, 2ms共2ms/0.5us=4000个周期</p></blockquote><h5 id="分散刷新" tabindex="-1"><a class="header-anchor" href="#分散刷新" aria-hidden="true">#</a> 分散刷新</h5><blockquote><p>每次读写完都刷新一行, 系统的存取周期变为1us, 前0.5us时间属于正常读写, 后0.5us时间属于刷新某行</p></blockquote><h5 id="集中刷新" tabindex="-1"><a class="header-anchor" href="#集中刷新" aria-hidden="true">#</a> 集中刷新</h5><blockquote><p>2ms内集中安排时间全部刷新, 系统的存取周期还是0.5us, 有一段使时间专门用于刷新, 无法访问存储器, 称为访存&quot;死区&quot; <br> 3872个周期(1936us)用于读写, 128个周期(64us)用于刷新</p></blockquote><h5 id="异步刷新" tabindex="-1"><a class="header-anchor" href="#异步刷新" aria-hidden="true">#</a> 异步刷新</h5><blockquote><p>2ms内每行刷新1次即可, 2ms内需要产生128次的刷新请求, 每隔2ms/128=15.6us一次, 每15.6us内有0.5us的&quot;死时间&quot;</p></blockquote><h3 id="dram的地址线复用技术" tabindex="-1"><a class="header-anchor" href="#dram的地址线复用技术" aria-hidden="true">#</a> DRAM的地址线复用技术</h3><p><img src="https://img1.imgtp.com/2022/10/18/MSiOlTBu.png" alt="" loading="lazy"></p><p>同时传送行地址和列地址会导致地址线很多(n条), 故采用地址线复用技术, 采用n/2条地址线, 先将行地址送入行地址缓冲器, 再将列地址送入列地址缓冲器, 最后分别送到行地址译码器和列地址译码器. 会导致地址线, 地址线的引脚减半</p><h2 id="_3-4-read-only-memory-rom" tabindex="-1"><a class="header-anchor" href="#_3-4-read-only-memory-rom" aria-hidden="true">#</a> 3.4 read only memory ROM</h2><h3 id="_1-了解各种rom" tabindex="-1"><a class="header-anchor" href="#_1-了解各种rom" aria-hidden="true">#</a> 1.了解各种ROM</h3><h4 id="mrom-mask-read-only-memory" tabindex="-1"><a class="header-anchor" href="#mrom-mask-read-only-memory" aria-hidden="true">#</a> MROM(Mask Read-Only Memory)</h4><p>掩模式只读存储器: 厂家按照客户需求, 在芯片生产过程中直接写入信息, 之后任何人不得重写(只能读出), 可靠性高, 灵活性差, 生产周期长, 知识和批量定制</p><h4 id="prom-programmable-read-only-memory" tabindex="-1"><a class="header-anchor" href="#prom-programmable-read-only-memory" aria-hidden="true">#</a> PROM(Programmable Read-Only Memory)</h4><p>可编程只读存储器: 用户可用专门的额PROM写入器写入信息, 写<strong>一次</strong>之后就不可更改</p><h4 id="eprom-erasable-programmable-read-only-memory" tabindex="-1"><a class="header-anchor" href="#eprom-erasable-programmable-read-only-memory" aria-hidden="true">#</a> EPROM(Erasable Programmable Read-Only Memory)</h4><p>允许用户写入信息, 之后采用某种方法擦除数据, 可进行多次重写</p><ul><li>UVEPROM(ultraviolet rays): 用紫外线照射8~20分钟, 擦除所有的信息</li><li>EEPROM(第一个E是Electrically): 可用&quot;电擦除&quot;的方式, 擦除特定的字</li></ul><h4 id="flash-memory" tabindex="-1"><a class="header-anchor" href="#flash-memory" aria-hidden="true">#</a> Flash Memory</h4><p>闪速存储器: 在EEPROM的基础上发展而来, 断电后也能保存信息, 且可进行多次快速的擦除和重写. 由于闪存需要先擦除再写入, 故闪存的&quot;写&quot;的速度要比&quot;读&quot;的速度慢. (U盘, SD卡就是闪存)</p><h4 id="ssd-solid-state-drives" tabindex="-1"><a class="header-anchor" href="#ssd-solid-state-drives" aria-hidden="true">#</a> SSD(Solid State Drives)</h4><p>固态硬盘: 由控制单元+存储单元(Flash芯片)组成, 与闪速存储器的核心区别在于控制单元不一样, 但存储介质都类似, 可进行多次快速地擦除和重写你, SSD速度快, 功耗低, 价格高. 目前个人电脑常常使用SSD取代传统的机械硬盘(手机辅存也使用Flash芯片, 但是相比SSD使用的芯片集成度高, 功耗低, 价格贵)</p><h3 id="_2-计算机内的重要rom" tabindex="-1"><a class="header-anchor" href="#_2-计算机内的重要rom" aria-hidden="true">#</a> 2.计算机内的重要ROM</h3><p><img src="https://img1.imgtp.com/2022/07/29/nYtjxKcC.svg" alt="" loading="lazy"></p><p>主板上的BIOS芯片就是ROM, 通常我们所说的内存条就是&quot;主存&quot;, 但事实上, 主板上的ROM芯片也是&quot;主存&quot;的一部分, 逻辑上, 主存由RAM+ROM组成, 且两者常统一编址</p><h2 id="_3-5-主存储器与cpu的连接" tabindex="-1"><a class="header-anchor" href="#_3-5-主存储器与cpu的连接" aria-hidden="true">#</a> 3.5 主存储器与CPU的连接</h2><h3 id="_1-增加主存的字长-位扩展" tabindex="-1"><a class="header-anchor" href="#_1-增加主存的字长-位扩展" aria-hidden="true">#</a> 1.增加主存的字长-位扩展</h3><ul><li>8K <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 8位 <img src="https://img1.imgtp.com/2022/07/29/8iNs7gjP.png" alt="" loading="lazy"></li></ul><h3 id="_2-增加主存的存储字数-字扩展" tabindex="-1"><a class="header-anchor" href="#_2-增加主存的存储字数-字扩展" aria-hidden="true">#</a> 2.增加主存的存储字数-字扩展</h3><ul><li>4 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 16K <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 8位 <img src="https://img1.imgtp.com/2022/07/29/b1T25mbi.png" alt="" loading="lazy"></li></ul><h3 id="_3-增加主存的存储字数-字位扩展" tabindex="-1"><a class="header-anchor" href="#_3-增加主存的存储字数-字位扩展" aria-hidden="true">#</a> 3.增加主存的存储字数-字位扩展</h3><ul><li>8 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 16K <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord">×</span></span></span></span> 4位 <img src="https://img1.imgtp.com/2022/07/29/I6IG9oJY.png" alt="" loading="lazy"></li></ul><h2 id="_3-6-双口ram-多模块存储器" tabindex="-1"><a class="header-anchor" href="#_3-6-双口ram-多模块存储器" aria-hidden="true">#</a> 3.6 双口RAM&amp;多模块存储器</h2><h3 id="_1-存取周期" tabindex="-1"><a class="header-anchor" href="#_1-存取周期" aria-hidden="true">#</a> 1.存取周期</h3><p><img src="https://img1.imgtp.com/2022/07/29/Al2vJCa2.svg" alt="" loading="lazy"></p><p>存取周期: 可以连续读/写的最短时间间隔</p><p>DRAM芯片的恢复时间比较长, 有可能是存取时间的几倍(SRAM的恢复时间较短), 如DRAM的存取时间为r, 存取周期为T, 则T=4r</p><p>产生的问题:</p><ol><li>多核CPU要访问内存, 怎么办</li><li>CPU的读写速度比主存快很多, 主存恢复时间太长怎么办?</li></ol><h3 id="_2-双端口ram" tabindex="-1"><a class="header-anchor" href="#_2-双端口ram" aria-hidden="true">#</a> 2.双端口RAM</h3><p>需要有两组完全独立的数据线, 地址线, 控制线. CPU, RAM中也要有更加复杂的控制电路</p><p><img src="https://img1.imgtp.com/2022/07/29/GgcV5Awh.png" alt="" loading="lazy"></p><p>两个端口对同一主存操作有以下四种情况:</p><ol><li>两个端口同时对不同的地址单元存取数据(可以实现)</li><li>两个端口同时对同一地址单元读出数据(可以实现)</li><li>两个端口同时对同一地址单元写入数据(写入错误)</li><li>两个端口同时对同一地址单元, 一个写入数据, 另一个读出数据(读出错误)</li></ol><ul><li><p>解决方法: 置&quot;忙&quot;信号为0, 由判断逻辑决定暂时关闭一个端口(即被延时), 未被关闭的端口正常访问, 被关闭的端口延长一个很短的时间段后再访问</p></li><li><p>作用: 优化多核CPU访问一根内存条的速度</p></li></ul><h3 id="_3-多体并行存储器" tabindex="-1"><a class="header-anchor" href="#_3-多体并行存储器" aria-hidden="true">#</a> 3.多体并行存储器</h3><blockquote><p>每个存储体存取周期为T, 存取时间为r, 假设T=4r <br> 连续访问: 00000, 00001, 00010, 00011, 00100</p></blockquote><p>为什么要考虑&quot;连续访问&quot;的情况? <br> 因为在实际应用中, 有很多数据是连续的存储在主存中的, 比如说数组, 程序的指令都是连续的存储在主存中的</p><h4 id="高位交叉编址" tabindex="-1"><a class="header-anchor" href="#高位交叉编址" aria-hidden="true">#</a> 高位交叉编址</h4><p><img src="https://img1.imgtp.com/2022/07/29/T86mJbBJ.png" alt="" loading="lazy"></p><blockquote><p>连续取n个存储字 <br> 耗时nT, 耗时5T</p></blockquote><h4 id="低位交叉编址" tabindex="-1"><a class="header-anchor" href="#低位交叉编址" aria-hidden="true">#</a> 低位交叉编址</h4><p>宏观上读写一个字的时间接近r</p><p><img src="https://img1.imgtp.com/2022/07/29/k9nNCcCD.png" alt="" loading="lazy"></p><blockquote><p>耗时T+4r=2T <br> 连续存n个存储字 <br> 耗时T+(n-1)r</p></blockquote><h3 id="_4-应该取第几个-体" tabindex="-1"><a class="header-anchor" href="#_4-应该取第几个-体" aria-hidden="true">#</a> 4.应该取第几个&quot;体&quot;?</h3><p>采用&quot;流水线&quot;的方式并行存取(宏观上并行, 微观上串行). 宏观上, 一个存储周期内, m体交叉存储器可以提供的数据量为单个模块的m倍</p><p>存取周期为T, 存取时间(总线传输周期)为r, 为了使流水线不间断, 应保证模块的数量m≥T/r:</p><ol><li>如果m&lt;T/r, 则会导致CPU需要等待</li><li>如果m&gt;T/r, 则会导致芯片闲置</li></ol><h3 id="_5-多模块存储器" tabindex="-1"><a class="header-anchor" href="#_5-多模块存储器" aria-hidden="true">#</a> 5.多模块存储器</h3><h4 id="多体并行存储器" tabindex="-1"><a class="header-anchor" href="#多体并行存储器" aria-hidden="true">#</a> 多体并行存储器</h4><p>每个模块都有相同的容量和存取速度 <br> 各模块都有独立的读写控制电路, 地址寄存器和数据寄存器. 它们既能并行工作, 又能交叉工作.</p><h4 id="单体多字存储器" tabindex="-1"><a class="header-anchor" href="#单体多字存储器" aria-hidden="true">#</a> 单体多字存储器</h4><p>每个存储单元存储m个字 <br> 总线宽度也为m个字 <br> 一次并行读出m个字 <br> 每次只能同时取m个字, 不能单独取其中某个字, 指令和数据在主存中必须是连续存放的</p><h3 id="_6-内存条" tabindex="-1"><a class="header-anchor" href="#_6-内存条" aria-hidden="true">#</a> 6.内存条</h3><p>单纯的扩容: 实现高位交叉的多体存储器 双通道: 实现低位交叉的多体存储器</p><p>买内存条时, 可挑选相同主频(主频反映的是存取周期, 如果主频不一样, 可能会导致高主频的内存降频), 相同容量(高容量的部分会按单通道处理)的两根来组成双通道</p><h2 id="_3-7-外部存储器" tabindex="-1"><a class="header-anchor" href="#_3-7-外部存储器" aria-hidden="true">#</a> 3.7 外部存储器</h2><p><img src="https://img1.imgtp.com/2022/10/18/0orcZlrQ.png" alt="" loading="lazy"></p><ul><li><p>磁盘存储器优点</p><ul><li>存储容量大，加个低</li><li>记录介质课重复使用</li><li>记录信息可长期保存而不丢失</li><li>非破坏读出</li></ul></li><li><p>磁盘设备的组成</p><ul><li>磁盘驱动器、磁盘控制器、盘片</li><li>一块硬盘有若干记录面，每个记录面若干磁道，每个磁道若干扇区 <ul><li>磁头数-&gt;记录面数</li><li>柱面数-&gt;每个盘面有多少磁道</li><li>扇区数-&gt;每条磁道有多少扇区</li></ul></li></ul></li><li><p>磁盘性能指标</p><ul><li>记录密度：盘片单位面积上记录的二进制信息量</li><li>磁盘容量：格式化容量小于非格式化</li><li>平均存取时间：寻道时间+旋转延迟时间+传输时间 <ul><li>延迟时间 = 旋转半周的时间</li><li>传输时间 = 信息量/传输速率 = 读XX信息的时间</li></ul></li><li>数据传输率：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mi>r</mi></msub><mo>=</mo><mi>r</mi><mo>×</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">D_r = r\times N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><ul><li>r-&gt;磁盘转数 N-&gt;每条磁道的容量</li></ul></li></ul></li><li><p>硬盘的工作过程</p><ul><li>寻址、读盘、写盘</li></ul><blockquote><p>读写操作串行、不可能既读又写；也不可能同时写两组</p></blockquote></li><li><p>磁盘阵列</p><ul><li>RAID0 无冗余无校验</li><li>RAID1 镜像磁盘阵列</li><li>RAID2 纠错的海明码</li><li>RAID3 位交叉奇偶校验</li><li>RAID4 块交叉奇偶校验</li><li>RAID5 无独立校验的奇偶校验阵列</li></ul><blockquote><p>使用多个磁盘提高了传输率；多个磁盘并行提高了数据吞吐量；镜像提高安全性；数据校验提供容错能力</p></blockquote></li><li><p>固态硬盘</p><ul><li>由一个或多个闪存芯片和闪存翻译层组成</li><li>数据以页为单位读写</li><li>一页所属的块被整块擦除才可写入这一页</li><li>随机写比随机慢</li></ul></li></ul><h2 id="_3-8-cache的基本概念和原理" tabindex="-1"><a class="header-anchor" href="#_3-8-cache的基本概念和原理" aria-hidden="true">#</a> 3.8 Cache的基本概念和原理</h2><h3 id="_1-存储系统存在的问题" tabindex="-1"><a class="header-anchor" href="#_1-存储系统存在的问题" aria-hidden="true">#</a> 1.存储系统存在的问题</h3><ol><li>经过多模块存储器优化后, 存储器的速度和CPU的速度差距依然很大</li><li>可以采用更加高速的存储单元设计, 但是会导致存储器的价格上升, 容量下降</li><li>故基于程序的局部性原理, 可以增加一个Cache层, 改善&quot;Cache-主存&quot;的层次</li></ol><h3 id="_2-cache的工作原理" tabindex="-1"><a class="header-anchor" href="#_2-cache的工作原理" aria-hidden="true">#</a> 2.Cache的工作原理</h3><p><img src="https://img1.imgtp.com/2022/07/29/KBmyndLC.svg" alt="" loading="lazy"></p><p>实际上, Cache被集成在CPU内部, Cache用SRAM实现, 速度快, 成本高</p><h3 id="_3-局部性原理" tabindex="-1"><a class="header-anchor" href="#_3-局部性原理" aria-hidden="true">#</a> 3.局部性原理</h3><ul><li>空间局部性: 在最近的未来要用到的信息(指令和数据), 很可能与现在正在使用的信息在存储空间上是邻近的(比如说数组元素, 顺序执行的指令代码)</li><li>时间局部性: 在最近的未来要用到的信息, 很可能是现在正在使用的信息(循环结构的指令代码)</li></ul><p>基于局部性原理, 不难想到, 可以把CPU当前访问地址&quot;周围&quot;的部分数据存放到Cache中. 程序B按照&quot;列优先&quot;访问二维数组, 空间局部性更差</p><h3 id="_4-性能分析" tabindex="-1"><a class="header-anchor" href="#_4-性能分析" aria-hidden="true">#</a> 4.性能分析</h3><p>设<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>c</mi></msub></mrow><annotation encoding="application/x-tex">t_c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为访问一次Cache所需要的时间, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7651em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为访问一次主存所需要的时间</p><ul><li><p>命中率H: CPU欲访问的信息已在Cache中的比率</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><msub><mi>N</mi><mi>c</mi></msub><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msub><mi>N</mi><mi>c</mi></msub><mo>+</mo><msub><mi>N</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">H =N_c/(N_c+N_m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul></li><li><p>缺失(未命中)率: M=1-H</p></li><li><p>Cache-主存系统的平均访问时间t为</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>H</mi><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>H</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><msub><mi>t</mi><mi>m</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">t=Ht_c+(1-H)(t_c+t_m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><blockquote><p>先访问Cache, 若Cache未命中再访问主存</p></blockquote></li><li>或者<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mi>H</mi><msub><mi>t</mi><mi>c</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>H</mi><mo stretchy="false">)</mo><msub><mi>t</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">t=Ht_c+(1-H)t_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><blockquote><p>同时访问Cache和主存, 若Cache命中则立即停止访问主存</p></blockquote></li></ul></li></ul><blockquote><p>假设Cache的速度是主存的5倍, 且Cache的命中率为95%, 则采用Cache后, 存储器性能提高多少(设Cache和主存同时被访问, 若Cache命中则中断访问主存)? <br> 设Cache的存取周期为t, 则主存的存取周期为5t <br> 若Cache和主存同时访问, 命中时访问时间为t, 未命中时访问时间为5t, 平均访问时间为0.95<em>t+0.05</em>5t=1.2t, 故性能为原来的5t/1.2t≈4.17倍 <br> 若先访问Cache再访问主存, 命中时访问时间为t, 未命中时访问时间为t+5t, 平均访问时间为0.95<em>t+0.05</em>6t=1.25t, 故性能为原来的5t/1.25t=4倍</p></blockquote><h3 id="_5-有待解决的问题" tabindex="-1"><a class="header-anchor" href="#_5-有待解决的问题" aria-hidden="true">#</a> 5.有待解决的问题</h3><h4 id="问题1" tabindex="-1"><a class="header-anchor" href="#问题1" aria-hidden="true">#</a> 问题1</h4><p>基于局部性原理, 不难想到, 可以把CPU目前访问的地址&quot;周围&quot;的部分数据放到Cache中. 如何界定&quot;周围&quot;?</p><p>将主存的存储空间&quot;分块&quot;, 如:每1KB为一块, 主存和Cache之间以&quot;块&quot;为单位进行数据交换</p><p><img src="https://img1.imgtp.com/2022/07/29/RmH39vFr.svg" alt="" loading="lazy"></p><p>主存的地址共22位: 块号12位, 块内地址10位, 4M=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span>, 1K=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup></mrow><annotation encoding="application/x-tex">2^{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10</span></span></span></span></span></span></span></span></span></span></span></span>, 整个主存被分为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding="application/x-tex">2^{12}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">12</span></span></span></span></span></span></span></span></span></span></span></span>=4096块</p><h4 id="问题2" tabindex="-1"><a class="header-anchor" href="#问题2" aria-hidden="true">#</a> 问题2</h4><p>如何区分Cache和主存的数据块对应关系? - Cache和主存的映射方式</p><h4 id="问题3" tabindex="-1"><a class="header-anchor" href="#问题3" aria-hidden="true">#</a> 问题3</h4><p>Cache很小, 主存很大, 如果Cache满了怎么办? - 替换算法</p><h4 id="问题4" tabindex="-1"><a class="header-anchor" href="#问题4" aria-hidden="true">#</a> 问题4</h4><p>CPU修改了Cache中的数据副本, 如何确保主存中数据母本的一致性? - Cache写策略</p><h2 id="_3-9-cache和主存的映射方式" tabindex="-1"><a class="header-anchor" href="#_3-9-cache和主存的映射方式" aria-hidden="true">#</a> 3.9 Cache和主存的映射方式</h2><h3 id="_1-全相联映射-随意放" tabindex="-1"><a class="header-anchor" href="#_1-全相联映射-随意放" aria-hidden="true">#</a> 1.全相联映射(随意放)</h3><p>主存中的每一块可以装入Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有Cache行的标记进行比较</p><blockquote><p>假设某个计算机的主存地址空间大小为256MB, 按照字节编址, 其数据Cache有8个Cache行, 行长为64B <br> Cache的总大小为512B, 256M=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>28</mn></msup></mrow><annotation encoding="application/x-tex">2^{28}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">28</span></span></span></span></span></span></span></span></span></span></span></span>, 主存的地址共28位, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>28</mn></msup></mrow><annotation encoding="application/x-tex">2^{28}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">28</span></span></span></span></span></span></span></span></span></span></span></span>/2^6=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>22</mn></msup></mrow><annotation encoding="application/x-tex">2^{22}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">22</span></span></span></span></span></span></span></span></span></span></span></span>, 主存块号共22位 28位 = 标记19位+ 块内地址共6位 + 行号3位 故Cache需要20位 = 有效位1位 + 标记19位 CPU访问主存地址1...1101 001110:</p><ol><li>主存地址的前22位, 对比Cache中所有块的标记</li><li>若标记匹配且有效位=1, 则Cache命中, 访问块内地址为001110的单元</li><li>若未命中或有效位=0, 则正常访问主存</li></ol></blockquote><h3 id="_2-直接映射-只能放固定位置" tabindex="-1"><a class="header-anchor" href="#_2-直接映射-只能放固定位置" aria-hidden="true">#</a> 2.直接映射(只能放固定位置)</h3><p><img src="https://img1.imgtp.com/2022/07/29/FcPZOXFP.png" alt="" loading="lazy"></p><p>主存块在Cache中的位置=主存块号 mod Cache总行数, 缺点是其他地方有空闲Cache块, 但是8号主存块不能使用</p><p>主存块号%(2^3), 相当于留下最后三位二进制数(若Cache总块数=2^n, 则主存块号末位n位直接反映它在Cache中的位置), 将主存块号的其余作为标记即可</p><blockquote><p>CPU访问主存地址0...01000 001110:</p><ol><li>根据主存块号的后3位确定Cache行</li><li>若主存块号的前19位与Cache标记匹配且有效位=1, 则Cache命中, 访问块内地址为001110的单元</li><li>若未命中或者有效位=0, 则正常访问主存</li></ol></blockquote><h3 id="_3-组相联映射-可放到特定分组" tabindex="-1"><a class="header-anchor" href="#_3-组相联映射-可放到特定分组" aria-hidden="true">#</a> 3.组相联映射(可放到特定分组)</h3><p>所属分组=主存块号%分组数</p><p>主存块号%2^2, 相当于留下最后两位</p><blockquote><p>CPU访问主存地址1...1101001110:</p><ol><li>根据主存块号的后2位确定所属分组号</li><li>若主存块号的前20位与分组内的某个标记匹配且有效位=1, 则Cache命中, 访问块内地址为001110的单元</li><li>若未命中或者有效位=0, 则正常访问</li></ol></blockquote><h2 id="_3-10-cache替换算法" tabindex="-1"><a class="header-anchor" href="#_3-10-cache替换算法" aria-hidden="true">#</a> 3.10 Cache替换算法</h2><h3 id="_1-随机算法-rand" tabindex="-1"><a class="header-anchor" href="#_1-随机算法-rand" aria-hidden="true">#</a> 1.随机算法(RAND)</h3><p>随机算法(RAND, Random) -- 若Cache已满, 则随机选择一块替换</p><blockquote><p>设总共有4个Cache块, 初始整个Cache为空. 采用全相联映射, 依次访问主存块1,2,3,4,1,2,5,1,2,3,4,5</p><table><thead><tr><th>访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Cache #0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>4</td><td>4</td></tr><tr><td>Cache #1</td><td></td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Cache #2</td><td></td><td></td><td>3</td><td>3</td><td>3</td><td>3</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td><td>5</td></tr><tr><td>Cache #3</td><td></td><td></td><td></td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Cache命中?</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td><td>是</td><td>否</td><td>是</td><td>是</td><td>否</td><td>否</td><td>是</td></tr><tr><td>Cache替换?</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td><td>否</td><td>否</td><td>是</td><td>是</td><td>否</td></tr></tbody></table></blockquote><p>随机算法 -- 实现简单, 但完全没考虑局部性原理, 命中率低, 实际效果很不稳定</p><h3 id="_2-先进先出算法-fifo" tabindex="-1"><a class="header-anchor" href="#_2-先进先出算法-fifo" aria-hidden="true">#</a> 2.先进先出算法(FIFO)</h3><p>先进先出算法(FIFO, First In First Out) -- 若Cache已满, 则替换最先被调入Cache的块</p><blockquote><p>设总共有4个Cache块, 初始整个Cache为空. 采用全相联映射, 依次访问主存块1,2,3,4,1,2,5,1,2,3,4,5</p><table><thead><tr><th>访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Cache #0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>5</td><td>5</td><td>5</td><td>5</td><td>4</td><td>4</td></tr><tr><td>Cache #1</td><td></td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>1</td><td>1</td><td>1</td><td>1</td><td>5</td></tr><tr><td>Cache #2</td><td></td><td></td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Cache #3</td><td></td><td></td><td></td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Cache命中?</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td></tr><tr><td>Cache替换?</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td><td>是</td></tr></tbody></table></blockquote><p>先进先出算法 -- 实现简单, 最开始按照#0#1#2#3放入Cache, 之后轮流替换#0#1#2#3, FIFO依然没有考虑局部性原理, 最先被调入Cache的块也有可能是被频繁访问的</p><p>抖动现象: 频繁的换入换出现象(刚被替换的块很快又被调入)</p><h3 id="_3-近期最少使用算法-lru" tabindex="-1"><a class="header-anchor" href="#_3-近期最少使用算法-lru" aria-hidden="true">#</a> 3.近期最少使用算法(LRU)</h3><p>近期最少使用算法(LRU, Least Recently Used) -- 为每一个Cache块设置一个&quot;计数器&quot;, 用于记录每个Cache块已经有多久没有被访问了. 当Cache满后替换&quot;计数器&quot;最大的</p><blockquote><p>设总共有4个Cache块, 初始整个Cache为空. 采用全相联映射, 依次访问主存块1,2,3,4,1,2,5,1,2,3,4,5</p><table><thead><tr><th>访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Cache #0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>5</td></tr><tr><td>Cache #1</td><td></td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Cache #2</td><td></td><td></td><td>3</td><td>3</td><td>3</td><td>3</td><td>5</td><td>5</td><td>5</td><td>5</td><td>4</td><td>4</td></tr><tr><td>Cache #3</td><td></td><td></td><td></td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>3</td><td>3</td><td>3</td></tr><tr><td>Cache命中?</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td><td>是</td><td>否</td><td>是</td><td>是</td><td>否</td><td>否</td><td>否</td></tr><tr><td>Cache替换?</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td><td>否</td><td>否</td><td>是</td><td>是</td><td>是</td></tr></tbody></table></blockquote><ol><li>命中时, 所命中的行的计数器清零, 比其低的计数器+1, 其余不变;</li><li>未命中且还有空闲行时, 新装入的行的计数器置0, 其余非空闲行全加1;</li><li>未命中且无空闲行时, 计数值最大的行的信息块被淘汰, 新装行的块的计数器置0, 其余全加1</li></ol><p>Cache块的总数=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>, 则计数器只需要n位. 且Cache装满后所有计数器的值一定不重复</p><p>LRU算法 -- 基于&quot;局部性原理&quot;, 近期被访问过的主存块, 在不久的将来也很有可能被再次访问, 因此淘汰最久没访问过的块是合理的. LRU算法的实际效果优秀, Cache命中率高. 若被频繁访问的主存块数量&gt;Cache行的数量, 则有可能发生抖动, 如:1,2,3,4,5,1,2,3,4,5,1,2...</p><h3 id="_4-最不经常使用算法-lfu" tabindex="-1"><a class="header-anchor" href="#_4-最不经常使用算法-lfu" aria-hidden="true">#</a> 4.最不经常使用算法(LFU)</h3><p>最不经常使用算法(LFU, Least Frequently Used) -- 为每一个Cache块设置一个&quot;计数器&quot;, 用于记录每个Cache块被访问过几次. 当Cache满后替换&quot;计数器&quot;最小的</p><blockquote><p>设总共有4个Cache块, 初始整个Cache为空. 采用全相联映射, 依次访问主存块1,2,3,4,1,2,5,1,2,3,4,5</p><table><thead><tr><th>访问主存块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>1</th><th>2</th><th>5</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>Cache #0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>Cache #1</td><td></td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>Cache #2</td><td></td><td></td><td>3</td><td>3</td><td>3</td><td>3</td><td>5</td><td>5</td><td>5</td><td>3</td><td>3</td><td>5</td></tr><tr><td>Cache #3</td><td></td><td></td><td></td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td><td>4</td></tr><tr><td>Cache命中?</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td><td>是</td><td>否</td><td>是</td><td>是</td><td>否</td><td>是</td><td>否</td></tr><tr><td>Cache替换?</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>否</td><td>是</td><td>否</td><td>否</td><td>是</td><td>否</td><td>是</td></tr></tbody></table></blockquote><p>新调入的块计数器=0, 之后每被访问一次计数器+1. 需要替换的时候, 选择计数器最小的一行</p><p>LFU算法 -- 曾经被经常访问的主存块在未来不一定会使用到(如: 微信视频聊天相关的块)并没有很好地遵循局部性原理, 因此实际运行效果不如LRU</p><h2 id="_3-11-cache写策略" tabindex="-1"><a class="header-anchor" href="#_3-11-cache写策略" aria-hidden="true">#</a> 3.11 Cache写策略</h2><h3 id="_1-写命中" tabindex="-1"><a class="header-anchor" href="#_1-写命中" aria-hidden="true">#</a> 1.写命中</h3><h4 id="回写法-write-back" tabindex="-1"><a class="header-anchor" href="#回写法-write-back" aria-hidden="true">#</a> 回写法(Write-back)</h4><p>当CPU对Cache写命中时, 只修改Cache的内容, 而不立即写入主存, 只有当此块被换出时才写回主存. 可以增设一个标志位(脏位), 以反映此块是否被CPU修改过</p><p>减少了访问次数, 但有数据不一致的隐患</p><h4 id="全写法-write-through" tabindex="-1"><a class="header-anchor" href="#全写法-write-through" aria-hidden="true">#</a> 全写法(Write-through)</h4><p>当CPU对Cache写命中的时候, 必须把数据同时写入Cache和主存, 一般使用写缓冲(Write buffer)</p><p>访存次数增加, 速度变慢, 但更能保证数据一致性</p><p>使用写缓冲, CPU写的速度很快, 若写操作不频繁, 则效果很好. 若写操作很频繁, 可能会因为写缓冲饱和而发生阻塞. 写缓冲是一个FIFO队列, 写缓冲可以解决速度不匹配的问题.</p><p><img src="https://img1.imgtp.com/2022/07/29/ugVNN3P4.png" alt="" loading="lazy"></p><h3 id="_2-写不命中" tabindex="-1"><a class="header-anchor" href="#_2-写不命中" aria-hidden="true">#</a> 2.写不命中</h3><h4 id="写分配法-write-allocate" tabindex="-1"><a class="header-anchor" href="#写分配法-write-allocate" aria-hidden="true">#</a> 写分配法(Write-allocate)</h4><p>当CPU对Cache写不命中的时候, 把主存中的块调入Cache, 在Cache中修改, 通常搭配回写法使用.</p><h4 id="非写分配法-not-write-allocate" tabindex="-1"><a class="header-anchor" href="#非写分配法-not-write-allocate" aria-hidden="true">#</a> 非写分配法(Not-write-allocate)</h4><p>当CPU对Cache写不命中时只写入主存, 不调入Cache, 搭配全写法使用</p><h3 id="_3-多级cache" tabindex="-1"><a class="header-anchor" href="#_3-多级cache" aria-hidden="true">#</a> 3.多级Cache</h3><p>现代计算机多采用多级Cache <br> 离CPU越近的速度越快, 容量越小 <br> 离CPU越远的速度越慢, 容量越大</p><p>各级Cache之间通常采用&quot;全写法&quot;+&quot;非写分配法&quot; <br> Cache-主存之间常采用&quot;回写法&quot;+&quot;写分配法&quot;</p><p><img src="https://img1.imgtp.com/2022/07/29/gNT9Y3f3.png" alt="" loading="lazy"></p><h2 id="_3-12-虚拟存储器" tabindex="-1"><a class="header-anchor" href="#_3-12-虚拟存储器" aria-hidden="true">#</a> 3.12 虚拟存储器</h2><ul><li>主存和辅存共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作，对应用程序员透明 <ul><li>虚拟存储器将主存或辅存的地址空间同一编址-&gt; 虚地址</li><li>虚地址比实地址要大得多</li><li>采用和Cache类似的基数，采用全相联映射</li></ul></li><li>CPU使用虚地址的过程：</li><li>根据虚地址、实地址的对应关系，判断该虚地址的存储单元是否装入主存中。</li><li>若存储单元在主存中，访问该单元；</li><li>若不在主存中，从辅存调入主存；</li><li>若主存满了，替换调入主存。</li></ul><h3 id="_1-页式虚拟存储器" tabindex="-1"><a class="header-anchor" href="#_1-页式虚拟存储器" aria-hidden="true">#</a> 1.页式虚拟存储器</h3><p>一个程序(进程)在逻辑上被分为若干个大小相等的&quot;页面&quot;, &quot;页面&quot;的大小与&quot;块&quot;的大小相同. 每个页面可以离散地放入不同的主存块中</p><ul><li>虚拟空间与主存空间都被划分成同样大小的页。</li><li>虚拟地址到物理地址由页表(在主存中)转换。</li></ul><p><img src="https://img1.imgtp.com/2022/10/18/uQdgyt8i.png" alt="" loading="lazy"></p><ul><li><p>有效位（装入位）：表示页是否在主存中。</p></li><li><p>脏位（修改位）：表示是否修改过。</p></li><li><p>引用位（使用位）：配合替换策略使用。</p></li><li><p>虚拟地址转换为主存地址 <img src="https://img1.imgtp.com/2022/07/29/MKWGShxp.png" alt="" loading="lazy"></p><ul><li>优点：页面的长度固定，页表简单，调入方便。</li><li>缺点是，由于程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。</li></ul></li></ul><h3 id="_2-快表tlb" tabindex="-1"><a class="header-anchor" href="#_2-快表tlb" aria-hidden="true">#</a> 2.快表TLB</h3><ul><li>快表(减少页虚拟存储器访存次数)</li><li>利用局部性原理，把经常访问的页表项放在快表TLB(在Cache里) 中，相应的页表称为慢表。转换时，先找快表，找不到再找慢表。</li><li>快表采用相联存储器(全相联、组相联)器件组成，按照查找内容访问，因此速度更快。但快表只是慢表的副本，无法得到更多的搜索结果。</li><li>Cache缺失处理由硬件完成；缺页处理由软件完成；而 TLB缺失既可以用硬件又可以用软件来处理。</li></ul><blockquote><p>快表是一种SRAM而内存是一种DRAM, 此外, 快表是一种&quot;相联存储器&quot;, 可以按照内容寻访</p></blockquote><h3 id="_3-tlb和cache的多级存储系统" tabindex="-1"><a class="header-anchor" href="#_3-tlb和cache的多级存储系统" aria-hidden="true">#</a> 3.TLB和Cache的多级存储系统</h3><h3 id="_4-段式、段页式" tabindex="-1"><a class="header-anchor" href="#_4-段式、段页式" aria-hidden="true">#</a> 4.段式、段页式</h3></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/WannXing/csnote/edit/main/demo/src/co/03.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/10/18 08:52:09</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: wanxing0122@163.com">Wannxing</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/csnote/co/02.html" class="nav-link prev" aria-label="第二章-数据的表示和运算"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->第二章-数据的表示和运算</div></a><a href="/csnote/co/04.html" class="nav-link next" aria-label="第四章-指令系统"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">第四章-指令系统<!----></div></a></nav><div class="giscus-wrapper input-top" style="display:block;"><div style="text-align:center">Loading...</div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">Wish you a better day</div><div class="copyright">Copyright © 2022 WanXing</div></footer><!--]--></div><!--]--><!----><!--]--></div>
    <script type="module" src="/csnote/assets/app.931c373c.js" defer></script>
  </body>
</html>
